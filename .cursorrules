# Projekt-Gesetze für we2026_5 (Tour-Planer)

Du bist der KI-Assistent für das Projekt "we2026_5". Dein Ziel ist es, die App stabil aufzubauen, während du das Design und die Struktur absolut unverändert lässt.

## I. Die 5 Grundregeln (Unverhandelbar)

1. **Single Source of Truth:** Vor jeder Änderung musst du den aktuellen Stand der Datei kennen. Arbeite niemals auf Basis von Vermutungen oder veralteten Versionen.
2.  Das Design-Gesetz gilt: "Nicht ein Buchstabe" am Design oder der UI darf ohne explizite Erlaubnis geändert werden.
3. **Correction before Innovation:** Bevor neue Funktionen (z.B. Offline-Modus) eingebaut werden, müssen ALLE "roten Linien" (Fehler) in den Dateien `build.gradle.kts` und `AndroidManifest.xml` beseitigt werden.
4. **Transparent Dependencies (Version Catalog):** Neue Bibliotheken (Room, Gemini AI, Firebase etc.) werden zuerst in `gradle/libs.versions.toml` definiert und dann per `alias` in die Gradle-Dateien integriert.
5. **Immediate Stop Command (Honesty Protocol):** Wenn du ein technisches Hindernis bemerkst (unbehebbarer Fehler, unklarer Paketname), stoppe sofort und melde es ehrlich. Versuche nicht, es "irgendwie" zu lösen.

## II. Das Drei-Schritte-Abgleich-Protokoll (3pro)

**Kurz: 3pro** = 1. Datei laden → 2. Datei ändern → 3. Abgleich vor/nach Änderung.

Bei jeder Datei-Bearbeitung folgst du diesem Ablauf:
1. **Datei laden:** Originaldatei laden und Inhalt bestätigen.
2. **Datei ändern:** Nur die nötigen Änderungen durchführen.
3. **Abgleich:** Datei vor und nach der Änderung vergleichen. Prüfen:
   - Wurde **nur** das geändert, was nötig war?
   - Wurden weder Code, Design noch Logik versehentlich kaputt gemacht?

Regel: Nach Änderungen immer Abgleich (Diff/Review), ob nur die beabsichtigten Änderungen drin sind und nichts anderes beschädigt wurde.

## III. Projektspezifische Daten
- **Projektname:** we2026_5 / githubwe2026
- **Firebase Storage:** gs://tourplaner2026.firebasestorage.app
- **GitHub-Pfad:** https://github.com/kenankara0000-design/we2026_5
- **Wichtig:** Gib Dateien immer als ganzes Stück aus, niemals in Teilen oder Fragmenten.

## IV. Firebase-Konfiguration (KRITISCH)
- **HAUPT-DATENBANK:** Die App nutzt **Firebase Realtime Database** (NICHT Firestore!)
- **WICHTIG:** Bei allen Firebase-bezogenen Änderungen immer beachten:
  - Repositories verwenden `FirebaseDatabase`, `DatabaseReference`, `ValueEventListener`
  - NICHT `Firestore`, `CollectionReference`, `DocumentSnapshot` verwenden
  - `FirebaseSyncManager` ist korrekt implementiert für Realtime Database
  - `AppModule.kt` registriert `FirebaseDatabase.getInstance()` korrekt
- **Für Zukunft:** Bei allen Firebase-Änderungen immer Realtime Database verwenden, niemals Firestore

## V. Code-Organisation und Dateistruktur
- **WICHTIG:** Bei jeder neuen Funktion, die hinzugefügt wird, MUSS mit dem Benutzer besprochen werden:
  - Ob es besser wäre, eine **separate neue Datei** zu erstellen
  - Oder ob die Funktion in eine **bestehende Datei** eingefügt werden soll
- **ABLAUF:**
  1. **Empfehlung geben:** Ich gebe meine fachliche Empfehlung mit Begründung (z.B. "Empfehlung: Separate Datei, weil...")
  2. **Optionen vorstellen:** Beide Optionen klar darstellen (neue Datei vs. bestehende Datei)
  3. **Auf Entscheidung warten:** NICHT selbstständig entscheiden - immer auf explizite Entscheidung des Benutzers warten
- Dies gilt für:
  - Neue Helper-Klassen
  - Neue Utility-Funktionen
  - Neue Manager-Klassen
  - Neue Adapter
    - Jede andere neue Code-Struktur

## VI. Effizienz & Token-Sparregeln (Strikte Befolgung)
- **10-File-Batch-Rule (Plan-Freigabe):** Bearbeite maximal **10 Dateien** in einem Block. Erstelle vorab einen detaillierten Plan für den gesamten Block. Erst nach einmaliger Freigabe des Plans durch den Benutzer wird der gesamte Block am Stück abgearbeitet.
- **Dynamische Kapazität:** 
    - Einfache Aufgaben (Strings, UI-Design): **90 % Power** (schnell).
    - Komplexe Logik (Datenbank, Algorithmen): **50 % Power** (höchste Präzision, doppelte Prüfung).
- **TPM-Schutz (Input/Output):** 
    - Nutze `grep`, um den **echten Ist-Zustand** zu verifizieren (Anti-Halluzination).
    - Lese bei jeder Dateibearbeitung **immer den Import-Block** mit (Import-Schutz gegen Kompilierfehler).
    - Nutze `StrReplace` für punktuelle Änderungen.
- **RPM-Schutz (Loops):** Stoppe nach maximal zwei erfolglosen Reparaturversuchen und frage den Benutzer.
- **Rhythmus:** Nutze die Pausen zwischen den Nachrichten bewusst zur Token-Regeneration.

## VII. Code-Änderungen vs. Zusammenfassungen (KRITISCH)
- **WICHTIG:** Wenn der Benutzer "zusammenfassen" schreibt, DARF KEIN Code geändert oder geschrieben werden!
- **NUR zusammenfassen:** Analysieren, beschreiben, Vorschläge machen - aber KEINE Dateien ändern
- **Code-Änderungen:** Nur wenn der Benutzer explizit "programmieren" oder ähnliche Anweisungen gibt
- **Regel:** "zusammenfassen" = NUR Text-Ausgabe, KEINE Tool-Calls für Code-Änderungen

## VIII. Step-by-Step Umsetzung & Zukunftspläne
- **Vor jeder Umsetzung fragen:** Bei Refactoring/Vorschlägen aus Berichten (z. B. BERICHT_TIEFENANALYSE_APP_2026.md) vor jeder einzelnen Umsetzung den Benutzer fragen: "Darf ich das umsetzen? (Ja / Nein / Zukunft)"
- **Ja** = sofort umsetzen (mit 3pro).
- **Nein** = nicht umsetzen, zum nächsten Punkt.
- **Zukunft** = Idee/Vorschlag in **ZUKUNFTSPLAENE.md** eintragen (mit kurzer Beschreibung), nicht jetzt umsetzen. Erst wenn der Benutzer später explizit "bauen" oder die Nummer/den Namen des Zukunftsplans nennt, umsetzen.
- **Regel Zukunftspläne:** Einträge in ZUKUNFTSPLAENE.md werden ohne ausdrückliche Freigabe des Benutzers nicht implementiert.