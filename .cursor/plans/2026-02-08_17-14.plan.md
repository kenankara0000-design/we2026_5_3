---
name: 2026-02-08_17-14
overview: Beleg pro Monat mit Datum/Uhrzeit pro Erfassung; Kundenpreise aus SevDesk (PartContactPrice), eigenes Firebase-Node kundenPreise; Erfassungs-Menü mit Neue Erfassung / Belege / Kundenpreise / Artikel verwalten; Erfassung zeigt nur Kundenpreis-Artikel (Fallback Allgemeine Preise).
todos: []
isProject: false
---

# Plan 2026-02-08 – Erfassung, Belege, Kundenpreise

**Status: Erledigt (umgesetzt).** Teil 1 (Belege pro Monat, Datum/Uhrzeit) und Teil 2 (Kundenpreise, Erfassungs-Menü mit vier Buttons, Belege-/Kundenpreise-Activities, Erfassung nur Kundenpreis-Artikel mit Fallback „Allgemeine Preise“) sind implementiert.

---

## Teil 1: Erfassung – Beleg pro Kunde pro Monat, Datum/Uhrzeit pro Erfassung

## Ziel (Nutzerwunsch)

- Bei **Erfassung starten** wird ein Kunde ausgewählt.
- **Pro Kunde pro Monat** soll **ein Beleg** existieren (nicht ein Beleg pro Erfassung).
- **In einem Beleg:** Mehrere Erfassungen möglich (z. B. heute eine gespeichert, morgen noch eine). **Vor jeder Erfassung** sollen **Datum und Uhrzeit** dieser Erfassung angezeigt werden.
- Belege bleiben pro Kunde (mehrere Belege pro Kunde, einer pro Monat).

## Ist-Zustand

- **Firebase:** `waschErfassungen` – pro Speichervorgang ein Eintrag mit `id`, `customerId`, `datum` (Long, Tagesanfang), `zeit` (String, z. B. "14:30"), `positionen`, `notiz`.
- **Speichern:** [WaschenErfassungViewModel.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungViewModel.kt) setzt beim Speichern `datum = getStartOfDay(now)` und `zeit = "HH:mm"` – Datum/Uhrzeit sind also bereits pro Erfassung vorhanden.
- **UI:** [WaschenErfassungErfassungenListeContent.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungErfassungenListeContent.kt) zeigt eine **flache Liste** aller Erfassungen des Kunden (jede Karte = eine Erfassung mit Datum + Zeit + „X Artikel“). Keine Gruppierung nach Monat.

## Vorgehen (ohne Datenmodell-Änderung)

Datenmodell und Firebase-Struktur bleiben unverändert. Nur **Darstellung und Navigation** werden angepasst: Gruppierung nach Monat (= „Beleg“), Anzeige von Datum und Uhrzeit vor jeder Erfassung innerhalb des Belegs. **Neue Dateien** statt ViewModel/Screen aufblähen (Zukunft, Performance).

1. **Gruppierung – eigene Datei**
  - **Neue Datei** (z. B. `BelegMonatGrouping.kt` oder `WaschenErfassungBelegState.kt`): Datenklasse `BelegMonat(monthKey, monthLabel, erfassungen)` und reine Gruppierlogik (Liste → nach Monat, neueste zuerst, innerhalb Monat Erfassungen absteigend). Monat aus `WaschErfassung.datum` mit `Calendar` oder `java.time.YearMonth` (minSdk 26+).
  - [WaschenErfassungViewModel.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungViewModel.kt): Ruft Gruppierlogik auf, hält z. B. `StateFlow<List<BelegMonat>>`; Berechnung **nur bei Änderung** von `erfassungenList`, nicht bei jedem Recomposition (Performance).
2. **UI: Belege-Liste – eigene Composable-Datei**
  - **Neue Datei** [WaschenErfassungBelegListeContent.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungBelegListeContent.kt): Statt flacher Liste in ErfassungenListeContent **Liste der Belege (Monate)** – Karten „Februar 2026“, „Januar 2026“ usw.; Klick öffnet Beleg-Detail.
  - [WaschenErfassungErfassungenListeContent.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungErfassungenListeContent.kt) nutzt diese Beleg-Liste oder wechselt je nach Kontext.
3. **Beleg-Detail – eigene Composable-Datei**
  - Neuer UI-State im ViewModel: `BelegDetail(customer, monthKey, erfassungenFürMonat)`.
  - **Neue Datei** [WaschenErfassungBelegDetailContent.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungBelegDetailContent.kt): Überschrift Kunde + Monat; pro Erfassung **Datum und Uhrzeit**, darunter Positionen; optional Löschen pro Erfassung, Zurück zur Belege-Liste. Nicht alles in [WaschenErfassungScreen.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungScreen.kt) – Screen bleibt schlank.
4. **Optional: Einzel-Erfassungs-Detail beibehalten**
  - State `ErfassungDetail` und [WaschenErfassungDetailContent.kt](app/src/main/java/com/example/we2026_5/ui/wasch/WaschenErfassungDetailContent.kt) erhalten; Klick auf Erfassung im Beleg → bisheriges Detail mit Löschen.
5. **Strings**
  - [strings.xml](app/src/main/res/values/strings.xml): „Beleg“, „Beleg [Monat]“ o. Ä.

## Kurzfassung

- **Firebase / WaschErfassung:** Keine Änderung
- **ViewModel:** Erfassungen nach Monat gruppieren; neuer State `BelegDetail(monthKey, erfassungen)`
- **ErfassungenListe:** Zeigt Belege (Monate); Klick → Beleg-Detail
- **Neu: Beleg-Detail:** Ein Monat, darin alle Erfassungen jeweils mit **Datum + Uhrzeit** + Positionen (evtl. + Link zum bestehenden Einzel-Detail/Löschen)

Damit gilt: **Ein Beleg = ein Monat pro Kunde;** mehrere Erfassungen in diesem Monat stehen **in einem** Beleg, **jeweils mit Datum und Uhrzeit** vor der Erfassung.

---

## Teil 2: Kundenpreise (SevDesk) und Erfassungs-Menü

### Artikelliste als Referenz

- **Eine** allgemeine Artikelliste (z. B. „Kochwäsche“, …) – Referenz/Stammdaten. Es wird **nicht** pro Kunde ein eigener Artikel angelegt.
- Pro Kunde werden **nur Preise** für diese Artikel gespeichert (Kunde + Referenz auf Artikel + Preis).
- Jeder Artikel, der in Kundenpreisen vorkommt, **muss** in der allgemeinen Artikelliste existieren.

### SevDesk API – Kundenpreise

- **Quelle:** [PROJECT_MANIFEST.md](PROJECT_MANIFEST.md) Abschnitt „SevDesk Kundenpreise“.
- **API-Modell:** **PartContactPrice** (GET /PartContactPrice?limit=100&offset=0, ggf. Paginierung). Optional Filter nach Kunde: `contact[id]=<Contact-ID>&contact[objectName]=Contact` oder clientseitig filtern.
- **Felder:** contact, part, type, priceNet, priceGross.
- **SevDeskApi.kt:** Neue Methode `getPartContactPrices(token)` für Abruf PartContactPrice.
- **Neue Datei** [SevDeskKundenpreiseImport.kt](app/src/main/java/com/example/we2026_5/sevdesk/SevDeskKundenpreiseImport.kt): Holt PartContactPrice, mappt SevDesk Contact-ID → App-Kunde (`kundennummer = "sevdesk_<id>"`), Part-ID → App-Artikel (`Article.sevDeskId`), schreibt in KundenPreiseRepository. [SevDeskImport.kt](app/src/main/java/com/example/we2026_5/sevdesk/SevDeskImport.kt) ruft nach Kontakte-Import auf. So bleibt Import-Logik getrennt; später „nur Kundenpreise aktualisieren“ ohne großes Refactoring.

### Speicherort Kundenpreise (Zukunftssicher)

- **Eigener Firebase-Knoten** **kundenPreise**, z. B. `kundenPreise/<customerId>/<articleId>` mit priceNet, priceGross. **Nicht** am Customer-Objekt – skaliert besser; nur bei Bedarf laden (Performance).
- **Neue Datei** [KundenPreis.kt](app/src/main/java/com/example/we2026_5/wasch/KundenPreis.kt) (Modell: customerId, articleId, priceNet, priceGross) – klar getrennt von Article.
- **Neues Repository** [KundenPreiseRepository.kt](app/src/main/java/com/example/we2026_5/data/repository/KundenPreiseRepository.kt): Nur für Firebase kundenPreise. Methode z. B. `getKundenPreiseForCustomerFlow(customerId)` – **nur diesen Kunden** laden, nie alle (Performance). Koin registrieren.

### Erfassungs-Menü (Oberbegriff „Erfassung“)

- **Erfassung** (Hauptbildschirm) → **Erfassungs-Menü** (ErfassungMenuActivity / ErfassungMenuScreen) mit **vier Buttons/Kacheln:**
  1. **Neue Erfassung** – wie bisher „Erfassung starten“ (Kunde wählen, Positionen, Speichern).
  2. **Belege** – öffnet **BelegeActivity** (eigene Activity) mit BelegeScreen/ViewModel: Kunde wählen → Monate (wie Teil 1), wiederverwendet Beleg-Gruppierung und -UI.
  3. **Kundenpreise** – öffnet **KundenpreiseActivity** (eigene Activity) mit KundenpreiseScreen/ViewModel: Kunde suchen/auswählen → Artikel mit Preisen für diesen Kunden. Zur Übersicht/Kontrolle. Optional im Kundendetail Link „Kundenpreise anzeigen“ mit vorausgewähltem Kunden.
  4. **Artikel verwalten** – wie bisher (globale Artikelliste).
- Wenn ErfassungMenuScreen zu voll: **neue Datei** [ErfassungMenuContent.kt](app/src/main/java/com/example/we2026_5/ui/main/ErfassungMenuContent.kt) mit den vier Kacheln, Screen nur Container.
- **Neue Dateien** für Kundenpreise: KundenpreiseActivity, KundenpreiseScreen.kt, KundenpreiseViewModel.kt. **Neue Dateien** für Belege-Übersicht: BelegeActivity, BelegeScreen.kt, BelegeViewModel.kt (nutzt BelegMonatGrouping / BelegListe/Detail-Content).

### Erfassung: Artikel je nach Kunde

- In **Neue Erfassung** bei ausgewähltem Kunden:
  - **Hat Kunde Kundenpreise:** Nur Artikel aus KundenPreiseRepository für diesen Kunden anzeigen, **mit Preisen**; Artikel-Stammdaten (Name, Einheit) aus ArticleRepository. Nur `getKundenPreiseForCustomerFlow(selectedCustomerId)` laden (Performance).
  - **Keine Kundenpreise:** Gesamte Artikelliste (wie bisher) mit **Hinweis** „Allgemeine Preise“ (bzw. „Standardpreise“ / „Allgemeine Artikelliste“).
- Keine schweren Berechnungen in Composable; Daten einmalig bzw. bei Kundenwechsel neu laden.

---

## Analyse – Zukunft & Performance

- **Teil 1:** Gruppierung in eigene Datei (BelegMonat/BelegGrouping); Beleg-Liste und Beleg-Detail als eigene Composable-Dateien; ViewModel behält State, Berechnung delegieren. Gruppierung nur bei Datenänderung, nicht bei jedem Recomposition.
- **Teil 2:** Eigenes Modell KundenPreis; eigenes Repository KundenPreiseRepository; SevDesk PartContactPrice in SevDeskApi + SevDeskKundenpreiseImport; Erfassungs-Menü ggf. Content in ErfassungMenuContent; Kundenpreise- und Belege-Übersicht als eigene Activities/Screens/ViewModels. kundenPreise nur pro customerId lesen.
- **Neue Dateien statt Refactoring:** BelegMonatGrouping.kt, WaschenErfassungBelegListeContent.kt, WaschenErfassungBelegDetailContent.kt; KundenPreis.kt, KundenPreiseRepository.kt; SevDeskKundenpreiseImport.kt; KundenpreiseActivity + Screen + ViewModel; BelegeActivity + Screen + ViewModel; optional ErfassungMenuContent.kt.

