---
name: ""
overview: ""
todos: []
isProject: false
---

## Plan: System verbessern durch gezielte Zentralisierung

**Datum/Zeit:** 2026-02-12_12-06  
**Kontext:** Reduktion von Duplikaten, weniger Bugs, konsistentes Verhalten (insb. Löschen/Bestätigen/Fehlerfeedback).

### Leitlinie

„Viel zentralisieren“ ist gut, wenn es wirklich überall gleich ist (UI-Pattern, Fehlerhandling, Logging). Nicht zentralisieren solltest du fachliche Löschlogik, die je Feature andere Nebenwirkungen hat.

### Vorschläge (hoher Nutzen, wenig Risiko)

- **Zentraler Delete-Flow (Wrapper):** überall gleich: Bestätigen → ausführen → Erfolg/Fehler anzeigen → optional Cache invalidieren. Pro Screen gibst du nur noch „was genau löschen“ rein.
- **Einheitlicher Confirm-Dialog für Compose:** (analog zu eurem DialogBaseHelper für Activities): gleiche Texte/Buttons, gleiche UX, weniger Copy/Paste.
- **Einheitliches Fehler-/Erfolgs-Feedback:** eine gemeinsame Snackbar/Toast-Strategie (inkl. AppErrorMapper), damit nicht jeder Screen anders reagiert.
- **„Delete“ gehört ins Repository/UseCase:** Screens sollten nur triggern; Kaskaden (Indexe/Referenzen/Storage/Listen) werden zentral an einer Stelle sauber erledigt.
- **IDs nur dort ergänzen, wo heute „Index/Datum“ wacklig ist:** z. B. Urlaubseinträge / Ausnahme-/Kunden-Termine als gespeicherte Einträge. Berechnete Termine weiter berechnet lassen (sonst explodiert Komplexität).
- **Konsequente String-Zentralisierung:** ein Standard-Text für „Löschen“ + optional „Objektname einsetzen“ (Kunde/Liste/Preis) statt viele ähnliche Varianten.

### Vorschläge (mehr Aufwand, aber langfristig stark)

- **Standardisierte Result-Typen** für Repository-Operationen (Erfolg/Fehler/Reason) → weniger „Sonderfälle“ pro Screen.
- **Mehr „Multi-Location Updates“** / Transaktionen in Firebase bei Löschkaskaden → verhindert halbfertige Zustände (das ist oft eine echte Bug-Quelle).
- **Tests für Terminberechnung + Delete-Ausnahmen:** da entstehen die teuersten Bugs; mit Tests wird’s stabiler ohne UI anzufassen.

---

### Detail-Analyse & Konkrete Maßnahmen (Gemini 3 Pro)

Nach sehr tiefer Analyse der Codebase (UI, Logik, Daten, Permissions, Ressourcen, Code-Hygiene) wurden folgende Bereiche identifiziert:

#### 1. Compose-Dialog-Duplikate (Priorität: Hoch)

- **Status:** `AlertDialog` Code (30-40 Zeilen) wird in Screens wie `TourPreislisteScreen`, `SevDeskImportScreen`, `WaschenErfassungScreen` fast identisch kopiert.
- **Risiko:** Inkonsistente Texte/Buttons, hoher Wartungsaufwand bei Design-Änderungen.
- **Maßnahme:** Zentraler **ComposeDialogHelper**. Kapselt Layout & State.

#### 2. Inkonsistentes Repository-Verhalten (Priorität: Hoch)

- **Status:** `CustomerRepository` nutzt teils eigenes Timeout (`awaitWithTimeout`), während `FirebaseRetryHelper` existiert aber ungenutzt bleibt. Mix aus `Boolean`, `Result`, und Exceptions als Rückgabe.
- **Risiko:** ViewModels wissen nicht, ob Fehler durch Netzwerk oder Logik entstanden sind. Fehlerbehandlung ist "Glückssache".
- **Maßnahme:** `FirebaseRetryHelper` und `Result<T>` Wrapper überall standardisieren.

#### 3. ViewModel-Boilerplate (Priorität: Mittel)

- **Status:** Wiederkehrendes Muster `launch { try { repo() } catch (e) { showSnackbar(e) } }`.
- **Maßnahme:** `BaseViewModel` oder Extension `launchWithHandling` einführen.

#### 4. Navigation & Intents (Priorität: Mittel)

- **Status:** Intents werden oft hardcoded erstellt (`Intent(this, TargetActivity::class.java)`). Extras-Keys (z.B. "CUSTOMER_ID") sind String-Literale in den Activities.
- **Risiko:** Tippfehler bei Keys führen zu Abstürzen oder leeren Screens. Refactoring ist schwer.
- **Maßnahme:** `AppNavigation` Object oder Factory-Methoden (`CustomerDetailActivity.createIntent(...)`) einführen.

#### 5. Permissions & Bild-Handling (Priorität: Mittel)

- **Status:** `CustomerPhotoManager` vermischt UI-Logik (Dialoge) mit Business-Logik (Upload). Permission-Handling (`registerForActivityResult`) wird in jeder Activity neu implementiert.
- **Maßnahme:** Extraktion eines `PermissionHelper` für Kamera/Storage.

#### 6. Termin-Logik (Status: Gut, aber komplex)

- **Status:** Die Logik ist in `TerminBerechnungUtils` gut zentralisiert. Es gibt viele Wrapper (`TourPlannerDateUtils`, `TerminAusKundeUtils`), aber das Kern-System ist stabil.
- **Empfehlung:** Hier **keine** große Änderung ("Don't touch running system"), außer gezielte Tests schreiben.

#### 7. Code-Hygiene & Ressourcen (Status: Viel "Noise")

- **Hardcoded Colors:** Viele Layouts nutzen Hex-Codes (`#1976D2`) direkt, obwohl `colors.xml` definiert ist. Erschwert Design-Anpassungen (z.B. Dark Mode).
- **Hardcoded Strings:** Intent-Keys (`"CUSTOMER_ID"`) und Firebase-Keys (`"kundenArt"`) sind Strings.
- **Logging:** `e.printStackTrace()` und `Log.e` oft ohne echte Fehlerbehandlung.

### Umsetzungsplan (Schritt für Schritt)

**Phase 1: Fundament (Ohne UI-Änderung)**

1. `ComposeDialogHelper.kt` erstellen.
2. `AppNavigation.kt` (oder `IntentFactory`) anlegen für typ-sichere Navigation.
3. `Result<T>` Wrapper als Standard definieren.

**Phase 2: Refactoring (Screen für Screen)**

1. **Dialoge:** `TourPreislisteScreen` & `SevDeskImportScreen` auf `ComposeDialogHelper` umstellen.
2. **Repos:** `CustomerRepository` auf `FirebaseRetryHelper` und `Result` umstellen.
3. **Navigation:** Hardcoded Intents in `MainActivity` durch Factory-Calls ersetzen.

**Phase 3: Cleanup & Hygiene**

1. **Constants:** Intent-Keys und Firebase-Keys in `Constants.kt` oder `companion object` auslagern.
2. **Resources:** Hardcoded Colors in Layouts durch `@color/...` Referenzen ersetzen.
3. **Logs:** `e.printStackTrace()` durch sauberes Logging (`AppLogger` oder `Timber`) ersetzen.

**Phase 4: Abschluss**

1. Alte Helper (`DialogBaseHelper` für Views) prüfen, ob sie noch gebraucht werden oder in Compose aufgehen.
2. `BaseViewModel` einführen, wenn sich Phase 2 bewährt hat.

