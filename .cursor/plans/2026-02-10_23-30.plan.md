---
name: "Wäsche/KW-Logik: Nächster Termin nur A, Rückgängig korrigieren, A+L mit KW+L"
overview: "Plan für Logik: (1) Wenn kein Wäsche gedrückt (KW), nächster Regular-Termin nur A. (2) KW rückgängig = alles korrigieren. (3) Bei A+L-Tag mit KW für A: Erledigung = KW + L."
todos: []
isProject: false
---

# Plan: Wäsche- und KW-Logik (Keine Wäsche, Rückgängig, A+L + KW)

**Erstellt:** 2026-02-10 23:30  
**Status:** Vorschläge ausgearbeitet – warte auf Freigabe.

---

## Ausgangslage (fachlich)

- **A** = Abholung, **L** = Auslieferung (Wäsche), **KW** = Keine Wäsche (an dem Tag war nur A, keine Wäsche zum Liefern).
- Reguläre Termine können **A**, **L** oder **A+L** (gleicher Tag) sein.
- Wenn an einem Abholungstag **KW** gedrückt wird: Es gab keine Wäsche → die *folgende* Auslieferung (L) entfällt logisch – nächster fälliger Termin ist die **nächste Abholung (nur A)**.
- Wenn **KW versehentlich** gedrückt und **rückgängig** gemacht wird: Alles soll wieder korrekt sein (inkl. Anzeige A+L und Erledigung nur mit KW+L bzw. A+L).
- An einem **A+L-Tag**: Volle Erledigung = entweder (A dann L) oder **(KW dann L)** – KW deckt A ab, L muss zusätzlich gedrückt werden.

---

## 1. Kein Wäsche gedrückt → Nächster Regular-Termin nur A (bzw. A+L/L wird zu nur A)

**Ziel:** Wenn für einen Kunden am letzten Abholungstag **KW** gedrückt wurde (keinerWäscheErfolgt, keinerWäscheErledigtAm), dann soll der **nächste** reguläre Termin, der sonst **A+L** oder **nur L** wäre, als **nur A** gelten (nur Abholung fällig, kein L).

**Begründung:** Keine Wäsche abgeholt → nichts zum Ausliefern → der „L-Termin“ dieser Runde entfällt; der nächste fällige Termin ist die nächste Abholung.

**Umsetzungsideen:**

- **Stelle:** Berechnung des nächsten Abholungs- und Auslieferungsdatums (z. B. `TourPlannerDateUtils.calculateAbholungDatum` / `calculateAuslieferungDatum`) bzw. überall, wo „nächster A-Termin“ und „nächster L-Termin“ für Anzeige/Fälligkeit genutzt werden (inkl. `TerminBerechnungUtils.berechneAlleTermineFuerKunde` oder Aufrufer).
- **Logik:** Wenn `customer.keinerWäscheErfolgt && customer.keinerWäscheErledigtAm > 0`, dann:
  - Das **Auslieferungsdatum**, das zu der KW-Abholung gehört (Abholung am Tag `keinerWäscheErledigtAm` + tageAzuL), soll **nicht** als fälliger L-Termin zählen.
  - Der **nächste** fällige Termin ist die **nächste Abholung** (nur A), bis diese erledigt ist.
- **Konkret:** Beim Berechnen von „hat Auslieferung heute“ / „nächster L-Termin“ prüfen: Liegt der berechnete L-Termin in der Zeit nach dem letzten KW-Abolungstag (innerhalb derselben „Runde“ tageAzuL)? Wenn ja, diesen L-Termin für Fälligkeit/Anzeige ausblenden oder überspringen – sodass nur der nächste A-Termin als nächster Regular-Termin erscheint.

**Vorschlag:** Eine zentrale Hilfsfunktion (z. B. in `TerminBerechnungUtils` oder `TourPlannerDateUtils`), die prüft, ob ein gegebenes Auslieferungsdatum „durch KW entfällt“ (weil die zugehörige Abholung mit KW erledigt wurde). Diese in `calculateAuslieferungDatum` und an allen Stellen einbauen, die „hat L heute“ / „nächster L-Termin“ bestimmen (z. B. `CustomerButtonVisibilityHelper`, `TourDataProcessor`, `TourListenProcessorImpl`, `WochentagslistenProcessorImpl`).

**Offen:** Soll nach der *nächsten* Abholung (nach KW) wieder normal A+L bzw. L gelten? (Vermutung: Ja – nur der eine L-Termin nach KW entfällt.)

---

## 2. KW versehentlich gedrückt und rückgängig gemacht → Alles korrigieren

**Ziel:** Wenn der Nutzer **KW** drückt und danach **Rückgängig** wählt, soll der Zustand wieder dem vor dem KW entsprechen: KW-Flags zurückgesetzt; wenn an dem Tag **A+L** war, sollen wieder **beide** Aktionen (A und L bzw. KW und L) für die Erledigung des Tages nötig sein.

**Ist-Zustand (Code):** In `TourPlannerErledigungHandler.handleRueckgaengig` wird bei `kwErledigtAmTag` bereits gesetzt:
- `keinerWäscheErfolgt = false`, `keinerWäscheErledigtAm = 0L`
- falls an dem Tag A und/oder L erledigt waren, werden auch `abholungErfolgt`/`auslieferungErfolgt` und zugehörige Zeitstempel zurückgesetzt.

**Bedeutung:** Nach Rückgängig ist „nichts erledigt“ für diesen Tag – korrekt. Die **Anzeige** (A+L wieder sichtbar, Buttons A und L wieder aktiv) kommt aus dem bestehenden Sheet-State (z. B. `CustomerButtonVisibilityHelper.getSheetState`), der ohne KW wieder A und L anzeigt.

**Vorschlag:** Prüfen, ob nach Rückgängig die Buttons **A** und **L** (bzw. KW und L) für den A+L-Tag tatsächlich wieder beide aktiv und sichtbar sind. Falls nicht (z. B. weil `pressedButton` oder ein anderer State hängen bleibt), State/UI so anpassen, dass nach Rückgängig klar „A+L“ und beide Aktionen verfügbar sind. Keine zusätzliche Backend-Logik nötig, wenn Rückgängig bereits alle Felder zurücksetzt.

**Offen:** Gibt es Sonderfälle (z. B. nur A oder nur L an dem Tag), bei denen nach KW-Rückgängig etwas falsch angezeigt wird? Falls ja, im Plan ergänzen und bei Umsetzung abdecken.

---

## 3. A+L-Tag: Erledigung = KW (für A) + L

**Ziel:** Wenn an einem Tag **A+L** fällig ist und der Nutzer **KW** drückt („Abholung ohne Wäsche“), gilt nur **A** als erledigt. Für die **volle Erledigung des Tages** muss zusätzlich **L** gedrückt werden (KW + L = A+L erledigt).

**Ist-Zustand (Code):** In `CustomerButtonVisibilityHelper`: Wenn `kwErledigtAmTag`, wird `sollLButtonAnzeigen = false` gesetzt – d. h. L wird ausgeblendet, sobald KW für den Tag erledigt ist. Das widerspricht der gewünschten Regel „KW + L für A+L“.

**Gewünschtes Verhalten:** An einem A+L-Tag:
- Nach **KW**: A gilt als erledigt, **L-Button soll sichtbar und aktiv bleiben**, bis L gedrückt wird.
- Erst **KW + L** (oder A + L) = Tag vollständig erledigt.

**Umsetzung:**

- **CustomerButtonVisibilityHelper (getSheetState):** Die Zeile `if (kwErledigtAmTag) sollLButtonAnzeigen = false` anpassen: Wenn an dem Tag **sowohl A als auch L** fällig sind (A+L-Tag), dann bei `kwErledigtAmTag` den L-Button **nicht** ausblenden – `sollLButtonAnzeigen` nur dann auf false, wenn an dem Tag **kein** L fällig ist (z. B. nur A-Tag mit KW).
- **enableL:** Sicherstellen, dass an einem A+L-Tag nach KW der L-Button **aktiv** ist (kein `customer.abholungErfolgt` nötig, weil KW bereits A abdeckt). Ggf. Bedingung: `enableL = … || (hatAuslieferungHeute && kwErledigtAmTag)` o. ä., damit nach KW am A+L-Tag L gedrückt werden kann.
- **TourDataProcessor / TourListenProcessorImpl / WochentagslistenProcessorImpl:** „Erledigt am Tag“ (isDone / wurdeAmTagVollstaendigErledigt): An einem A+L-Tag soll **vollständig erledigt** = (A erledigt ODER KW erledigt) **und** L erledigt. Bereits so? Prüfen: Wenn `kwErledigtAmTag` und noch nicht `auslieferungErfolgt` für diesen Tag, darf der Kunde nicht als „erledigt“ in Erledigt-Sektion landen; erst wenn L auch erledigt ist.

**Vorschlag:** Zuerst Helper anpassen (L anzeigen und aktiv lassen bei A+L-Tag trotz KW), dann in allen Prozessoren die „isDone“-Logik für A+L-Tag explizit: `(abholungErledigtAmTag || kwErledigtAmTag) && auslieferungErledigtAmTag`.

---

## 4. Kurzfassung und Reihenfolge

| Nr | Thema | Inhalt |
|----|--------|--------|
| 1 | Nächster Termin nur A nach KW | Nach KW: L-Termin dieser Runde für Fälligkeit/Anzeige ausblenden; nächster Regular = nur A. Zentrale Prüfung „L entfällt wegen KW“ einbauen. |
| 2 | KW rückgängig | Bereits Rückgabe von KW + A/L; prüfen ob UI nach Rückgängig wieder A+L zeigt und beide Buttons aktiv. |
| 3 | A+L mit KW + L | An A+L-Tag: Nach KW L-Button weiter anzeigen und aktiv lassen; „erledigt“ erst bei KW+L (bzw. A+L). Helper + Prozessoren anpassen. |

**Reihenfolge (Vorschlag):** Zuerst **3** (A+L mit KW+L), dann **1** (nächster Termin nur A), dann **2** (Rückgängig-Verhalten prüfen). So ist die Erledigungslogik am aktuellen Tag konsistent, bevor die „nächste“ Termin-Logik geändert wird.

---

## 5. Betroffene Dateien (Überblick)

- **Erledigung / KW / Rückgängig:** `TourPlannerErledigungHandler.kt`, `CustomerButtonVisibilityHelper.kt`
- **Termin-Berechnung / Fälligkeit:** `TourPlannerDateUtils.kt`, `TerminBerechnungUtils.kt`
- **Listen/Tour-Anzeige (isDone, Sektionen):** `TourDataProcessor.kt`, `TourListenProcessorImpl.kt`, `WochentagslistenProcessorImpl.kt`
- **UI Erledigung:** `ErledigungTabErledigungContent.kt`, `TourPlannerScreen.kt`, `TourPlannerActivity.kt`

---

## 6. Offene Punkte (für dich)

1. **Nach KW:** Soll genau **ein** L-Termin entfallen (der zu dieser Abholung gehörige), und ab der übernächsten Abholung wieder normal A+L/L? (Ja angenommen.)
2. **Listen-Kunden:** Gleiche Regeln wie für Regelkunden (KW → nächster nur A; A+L mit KW+L)?
3. **Rückgängig:** Reicht die aktuelle Rückgängig-Logik, oder sollen zusätzlich z. B. „nächster Termin nur A“-Zustände (wenn schon berechnet) explizit invalidiert werden?

---

**Nächster Schritt:** Warte auf deine Freigabe bzw. Rückmeldung zu den Vorschlägen und offenen Punkten. Keine Code-Änderung ohne Freigabe (vgl. Regel „Nichts kaputt machen“).
