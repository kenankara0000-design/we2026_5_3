---
name: ""
overview: ""
todos: []
isProject: false
---

# Änderungs- und Funktionsplan

**Stand:** 07.02.2026  
**Status:** **Erledigt (Prio 1–3 umgesetzt).** Punkt 3, 4, 5 für spätere Phasen offen.

**Prioritäten (Prio):**

- **Prio 1 (schnell):** Punkt 2 – PLZ/Stadt „(Optional)“ entfernen (nur strings.xml). **Erledigt**
- **Prio 2:** Punkt 1 – Erledigt-Bereich immer sichtbar + Grün anpassen (Option A #43A047). **Erledigt**
- **Prio 3:** Punkt 6.2 Debounce, Punkt 6.4 LazyColumn prüfen. **Erledigt** (Debounce 250 ms; LazyColumn war bereits vorhanden)
- **Prio 4–6 (spätere Phasen):** Punkt 3 (Tabs/Struktur), Punkt 4 (monatliche Termine), Punkt 5 (Denormalisierung) – konzeptionell festgehalten, Umsetzung wenn freigegeben.

**Plan-Dateinamen:** Immer `YYYY-MM-DD_HH-MM.plan.md` (z. B. `2026-02-07_17-34.plan.md`), damit eine Timeline entsteht, wann was geplant wurde.

---

## Vorbemerkung

- Jeder Punkt wird mit dir durchgesprochen.
- Neue Punkte und Präzisierungen werden in diesen Plan aufgenommen.
- Code-Änderungen erfolgen erst nach deiner ausdrücklichen Freigabe.

---

## Geplante Punkte

### 1. TourPlanner: Erledigt-Bereich immer sichtbar + Grün anpassen

- **Aktuell:** Der Erledigt-Button in der TopBar wird nur angezeigt, wenn mindestens ein Termin erledigt wurde (`erledigtCount > 0`). Siehe [TourPlannerTopBar.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerTopBar.kt) Zeile 168: `if (erledigtCount > 0)`.
- **Gewünscht:**
  - Erledigt-Bereich (Button) **immer** sichtbar, an derselben Stelle wie jetzt. Bei 0 Erledigten z. B. „Erledigte (0)“; Klick öffnet Sheet mit leerem Inhalt oder Hinweis.
  - Farbe „besser anderes Grün“ – Vorschläge siehe unten.
- **Betroffene Stellen:**
  - [TourPlannerTopBar.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerTopBar.kt): Bedingung `erledigtCount > 0` entfernen/anpassen, Button immer rendern.
  - [TourPlannerScreen.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerScreen.kt) / Sheet: Sheet auch bei `erledigtCount == 0` öffnen können; Inhalt dann leer oder „Keine erledigten Termine“.
  - [TourPlannerViewModel.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerViewModel.kt): `erledigtSheetContent` ist bei 0 aktuell `null` – evtl. leeres Objekt liefern, damit Sheet sich einheitlich öffnet.
- **Aktuelle Grün-Farben:**
  - TopBar-Button + Erledigt-Sheet/Header: `section_done_bg` = **#E8F5E9** (sehr helles Grün, Material Green 50) in [colors.xml](app/src/main/res/values/colors.xml).
  - Häkchen-Badge in Kundenzeile: `ErledigtBadgeGreen` = **#388E3C** (dunkles Grün, Material Green 800) in [TourPlannerCustomerRow.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerCustomerRow.kt).
- **Grün-Vorschläge (für Erledigt-Bereich / Button):**
  - **Option A – Kräftiger, gut lesbar:** Material Green 600 **#43A047** (mittleres Grün, wirkt „erledigt“, nicht zu dunkel).
  - **Option B – Etwas ruhiger:** Material Green 700 **#388E3C** (wie das aktuelle Badge-Grün, einheitlicher Look).
  - **Option C – Heller, aber satt:** Material Green 100 **#C8E6C9** (deutlich grüner als #E8F5E9, bleibt hell).
  - **Option D – Dezent:** Grün 200 **#A5D6A7** (mittelhell, gut sichtbar).
  - *(Badge-Häkchen können gleich bleiben oder an gewählte Option angeglichen werden.)*

### 2. Kunden Anlegen: „(Optional)“ bei PLZ und Stadt entfernen

- **Bereich:** Fenster „Kunden Anlegen“ (AddCustomer) – Stammdaten-Formular.
- **Aktuell:** Bei den Feldern **PLZ** und **Stadt** steht im Label der Text „(Optional)“.
- **Gewünscht:** Den Zusatz „(Optional)“ bei PLZ und Stadt **löschen** – Labels nur noch „PLZ“ bzw. „Stadt“.
- **Betroffene Stellen:**
  - [strings.xml](app/src/main/res/values/strings.xml): `label_zip_optional` (derzeit „PLZ (Optional)“) und `label_city_optional` (derzeit „Stadt (Optional)“) auf „PLZ“ bzw. „Stadt“ ändern.
  - Das Formular [CustomerStammdatenForm.kt](app/src/main/java/com/example/we2026_5/ui/addcustomer/CustomerStammdatenForm.kt) nutzt diese Strings (Zeilen 80, 87) – keine Kotlin-Änderung nötig, nur String-Anpassung.

### 3. Kunden-Anlegen/Bearbeiten und Übersicht: Ein Muster für die ganze App (skalierbar)

**Ziel:** Einmal eine klare Struktur etablieren, die mit wachsender Kundenzahl und neuen Bereichen (Rechnungen, Belege, …) mitwächst – ohne jedes Mal alles umzubauen.

- **1) Kunden-Detail (Bearbeiten) als zentrale, getabte Oberfläche**
  - Beim Öffnen eines Kunden: Tabs, z. B. **Stammdaten | Termine & Tour |** (später: **Rechnungen | Belege | Fotos | …**).
  - Jeder Bereich hat seinen eigenen Tab; kein einziges Riesenscroll mit allem.
  - Neue Bereiche (Rechnungen, Belege) = neuer Tab, Rest bleibt unverändert.
  - Vorteil: Klar getrennt, erweiterbar, gleiches Muster für alle Kunden.
- **2) Kunden Anlegen bewusst schlank – Rest im Detail**
  - Beim Anlegen nur das Nötigste: Name, Adresse (PLZ, Stadt), Telefon, Kundenart – evtl. zweiter Schritt „Termine (optional)“ mit Abhol-/Auslieferungstagen.
  - Alles Weitere (Tour, Kundennummer, Tags, Notizen, …) nicht im Anlegen-Dialog ausufern lassen. Nach dem Speichern direkt in die **Kunden-Detail-Ansicht** springen (Tab „Termine & Tour“ oder „Stammdaten“); dort weiter bearbeiten.
  - Vorteil: Anlegen bleibt schnell; die „volle“ Oberfläche ist immer die getabte Detail-Ansicht – die wächst mit der App.
- **3) Kunden-Übersicht: Liste + Öffnen ins Detail**
  - Übersicht = Liste (evtl. Suche/Filter bei vielen Kunden), eine Zeile = ein Kunde mit Kerninfos (Name, Ort, nächster Termin, ggf. Status-Icon).
  - Kein volles Bearbeiten-Formular in der Liste; Klick auf Kunde → **Detail mit Tabs** (wie oben). Später evtl. Schnellaktionen in der Zeile (z. B. „Als erledigt“, „Anruf“).
  - Vorteil: Übersicht bleibt leicht; bei 500+ Kunden bleibt das Detail der eine Ort für alles.
- **4) Einheitliches Muster für die ganze App**
  - Überall: **Übersicht (Liste) → Detail (Tabs) → bei Bedarf Unterdialoge/Sheets** (z. B. eine Rechnung bearbeiten, Beleg hochladen).
  - Gleiches Prinzip später für andere Entitäten (z. B. Touren, Lieferanten) nutzbar.
  - Vorteil: Einmal verstanden, überall gleich – „ein für alle Mal“ in der Struktur.
- **Zusätzliche Ideen (optional):**
  - Nach „Kunde anlegen“: Hinweis „Kunde angelegt. Termine & Tour jetzt einrichten?“ und direkt Detail mit Tab Termine öffnen – ein Bearbeiten-Fluss, kein zweiter Riesen-Dialog.
  - Optionale Felder in Tabs einheitlich handhaben (z. B. kleine „Zusatzinfos“-Sektion), damit Stammdaten/Termine nicht überladen wirken.
  - Rechnungen/Belege später: eigener Tab „Rechnungen“ mit Liste + Klick öffnet Sheet/Dialog – dasselbe Tab-Prinzip, App wächst sauber mit.

### 4. Termine „erster Montag im Monat“ / „zweiter Donnerstag im Monat“ (monatliche Wochentags-Regel)

**Ausgangslage:** Manche Kunden haben Termine wie „immer am ersten Montag des Monats“ oder „am zweiten Donnerstag des Monats“. Bisher gibt es u. a. wöchentliche Intervalle (Wochentag + Intervall) und flexible Zyklen – keine monatliche „Woche + Wochentag“-Logik.

**Vorschlag zur Lösung (konzeptionell, ohne Code):**

- **Regel-Typ:** Eine neue Art Termin-Regel/Intervall: **monatlich nach Woche + Wochentag**. Pro Monat wird genau ein Termin (Abholung und/oder Auslieferung) berechnet.
- **Was gespeichert werden muss:**
  - **Wochentag** (Montag … Sonntag, wie bisher 0–6).
  - **Woche im Monat:** 1 = erste, 2 = zweite, 3 = dritte, 4 = vierte, 5 = „letzte“ (z. B. letzter Donnerstag). So lassen sich „erster Montag“, „zweiter Donnerstag“, „letzter Freitag“ abbilden.
  - Ob es für **Abholung**, **Auslieferung** oder beide gilt (analog zu bestehenden Regeln).
- **Berechnung:** Für einen gegebenen Monat: z. B. „2. Donnerstag“ = den zweiten Donnerstag in diesem Monat ermitteln; „letzter Freitag“ = letzten Freitag im Monat. Daraus entstehen die konkreten Termin-Daten für TourPlanner und Listen.
- **Einarbeitung in die App:**
  - **Termin-Regel/Intervall:** Entweder neuer Regel-Typ (z. B. „Monatlich (Wochentag)“) neben WEEKLY/FLEXIBLE_CYCLE/ADHOC, oder Erweiterung der bestehenden Struktur um „monatlich + Woche + Wochentag“. Bestehende wöchentliche Kunden bleiben unverändert.
  - **UI:** Bei der Auswahl der Termin-Regel eine Option wie „Monatlich (z. B. 1. Montag, 2. Donnerstag)“; dann Auswahl: **Woche** (1./2./3./4./letzte) und **Wochentag** (Mo–So). Anzeige z. B. „Jeden 2. Donnerstag im Monat“.
  - **TourPlanner / Überfällig / Heute:** Die bestehende Logik „welche Termine gibt es an Tag X?“ muss um diese monatlichen Termine ergänzt werden: für das angezeigte Datum prüfen, ob es der „erste Montag“ usw. dieses Monats ist – wenn ja, Termin anzeigen.
- **Optional später:** „Jeden letzten Werktag im Monat“ oder „immer am 15.“ als weitere Varianten – gleiches Prinzip (Regel-Typ + Parameter), Erweiterung ohne Grundkonzept zu ändern.

**Zusammenfassung:** Neue Regel „monatlich nach Woche + Wochentag“ (1.–4. oder letzte Woche + Mo–So), in Datenmodell und Termin-Berechnung integrieren, in der UI klar auswählbar und lesbar (z. B. „Jeden 2. Donnerstag im Monat“). Bestehende Kunden und wöchentliche Regeln unberührt.

### 5. „Ohne Tour“-Kunden: Ressourcen sparen, App flüssig halten (skalierbar)

**Ziel:** Kunden mit „Ohne Tour“ sollen im Tour-Kontext **keine** Ressourcen verbrauchen (kein Laden, kein Parsing, keine Verarbeitung). Die App soll **immer flüssig laufen** – auch bei wachsender Kundenzahl (z. B. 1000+ Kunden, davon nur 650 in der Tour).

**Ausgangslage:** Aktuell werden alle Kunden aus Firebase geladen; der TourPlanner filtert danach mit `.filter { !it.ohneTour }`. „Ohne Tour“-Kunden werden also mitgeladen, mitgeparst und belegen Speicher – sie verbrauchen Ressourcen, obwohl sie für die Tour nicht gebraucht werden.

**Gewählte Lösung (langfristig, skalierbar): Denormalisierung**

- **Eigener Firebase-Knoten nur für Tour-Kunden**, z. B. `customers_for_tour`. Enthält nur Kunden mit `ohneTour == false` (vollständige Daten oder alle für Tour nötigen Felder).
- **TourPlanner (und alle reinen Tour-Features)** abonnieren **nur** diesen Knoten – keine Abfrage auf den vollen `customers`-Knoten. „Ohne Tour“-Kunden werden für die Tour nie geladen, nie verarbeitet.
- **Kundenverwaltung, Listen, Export** bleiben am Knoten `customers` (alle Kunden) – unverändert.
- **Sync beim Speichern:** Bei jeder Kundenänderung (und beim Wechsel von `ohneTour`) den Knoten `customers_for_tour` mitführen: Kunde mit Tour → in `customers_for_tour` schreiben/aktualisieren; Kunde „Ohne Tour“ → aus `customers_for_tour` entfernen.
- **Vorteil:** Netzwerk, Speicher und CPU für die Tour wachsen nur mit der **Anzahl der Tour-Kunden**, nicht mit der Gesamt-Kundenzahl. Bei 1000 Kunden, 650 in der Tour: Tour-Seite lädt nur 650. App bleibt flüssig.

**Nicht vergessen:** Die App muss **immer flüssig laufen**. Umsetzung so gestalten, dass Parsing und UI-Arbeit weiterhin im Hintergrund/effizient bleiben; große Listen nicht auf dem Main-Thread; ggf. vorhandene Performance-Regeln (z. B. aus `.cursor/rules` oder PROJECT_MANIFEST) einhalten.

### 6. TourPlanner Performance: vier Maßnahmen (für 1000+ Kunden, flüssiger Lauf)

- **1) Nur Tour-Kunden laden**  
Siehe **Punkt 5** (Denormalisierung, Knoten `customers_for_tour`). Wichtigste Maßnahme – TourPlanner lädt und verarbeitet nur noch Tour-Kunden.
- **2) Debounce für die Pipeline**  
Änderungen an Kunden/Listen (z. B. durch Firebase-Updates) nicht sofort in die volle Tour-Berechnung durchreichen. Stattdessen z. B. 200–300 ms sammeln und die Pipeline **nur einmal** pro Zeitfenster ausführen. Verhindert, dass bei vielen schnellen Updates die CPU mehrfach hintereinander voll rechnet.
- **3) Schwere Arbeit im Hintergrund**  
Die Tour-Berechnung (`processTourData` und Vorverarbeitung) weiter auf einem Hintergrund-Dispatcher laufen lassen; keine großen Listen auf dem Main-Thread verarbeiten. Bereits so vorgesehen – bei Umsetzung beibehalten.
- **4) Liste virtuell (LazyColumn)**  
Die Tour-Liste als virtuelle Liste (z. B. LazyColumn) umsetzen, sodass nur sichtbare Zeilen aufgebaut werden. So bleibt die UI auch bei hunderten Einträgen flüssig. **Erledigt:** Bereits in [TourPlannerScreen.kt](app/src/main/java/com/example/we2026_5/ui/tourplanner/TourPlannerScreen.kt) mit LazyColumn umgesetzt.

---

## Weitere Punkte

*(Folgen nach deinen Anweisungen.)*

---

## Nächster Schritt (für Zukunft)

- **Punkt 1, 2, 6.2, 6.4:** Umgesetzt (Erledigt-Bereich immer sichtbar, Grün #43A047, PLZ/Stadt ohne „(Optional)“, Debounce 250 ms, LazyColumn bestätigt).
- **Punkt 3, 4, 5:** Für spätere Phasen – bei Freigabe umsetzen (Tabs/Struktur, monatliche Termine, Denormalisierung).

