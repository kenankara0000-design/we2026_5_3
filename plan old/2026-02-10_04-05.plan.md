---
name: ""
overview: ""
todos: []
isProject: false
---

# Plan: Termine-Logik (Prototyp v2 + Mehrere A/L-Tage)

**Erstellt:** 2026-02-10  
**Quellen:** `app_prototyp_termine_v2.html`, `app_prototyp_termine_mehrere_atage.html`  
**Randbedingung:** Rückwärtskompatibilität für 2. Handy (siehe `.cursor/rules/zweites-geraet-kompatibilitaet.mdc`)

---

## 1. Ziel

Die Termin-Logik der App soll die in den Prototypen definierten Features abbilden:

- **Mehrere A- und L-Tage** (Mehrfachauswahl)
- **Same-Day-Strategie:** A und L gleicher Wochentag → L am selben Tag (0) oder L eine Woche später (7)
- **Zuordnung A↔L** bei unterschiedlichen A/L-Tagen: 1:1 nach Reihenfolge
- **Vordefinierte Intervalle** (7, 14, 21, 28 … Tage)
- **Live-Preview** in natürlicher Sprache

---

## 2. Ist-Zustand (App, Stand Feb 2026)


| Komponente                                                        | Aktuell                                                                                |
| ----------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| `CustomerIntervall`                                               | abholungDatum, auslieferungDatum, intervallTage, regelTyp, tageAzuL (implizit aus A–L) |
| `TerminAusKundeUtils.erstelleIntervalleAusKunde`                  | Ein Intervall **pro** A-Wochentag; L = A + tageAzuL                                    |
| `effectiveAbholungWochentage` / `effectiveAuslieferungWochentage` | Listen (0–6)                                                                           |
| `tageAzuL`                                                        | Tage zwischen A und L; bei gleichem Tag bisher nicht explizit 0/7                      |
| Same-Day-Strategie                                                | **Nicht vorhanden** – bei gleichem A/L-Tag unklar ob L = A+0 oder A+7                  |


---

## 3. Datenmodell-Erweiterungen (rückwärtskompatibel)

### 3.1 CustomerIntervall (oder Customer)

**Neues optionales Feld:**

- `sameDayLStrategy: Int?` – nur relevant wenn A- und L-Wochentag gleich
  - `0` = L am selben Tag wie A (L = A + 0)
  - `7` = L eine Woche später (L = A + 7)
  - `null` / fehlend = Fallback: wie bisher (z. B. 0 oder 7 – vorher festlegen)

**Firebase:** Neues Feld ergänzen. Alte App ignoriert es.

### 3.2 Zuordnung A↔L bei unterschiedlichen Tagen

Aktuell: `erstelleIntervalleAusKunde` erzeugt pro A-Tag ein Intervall mit `L = A + tageAzuL`.  
Bei mehreren A- und L-Tagen: Zuordnung nach **Reihenfolge** (1. A → 1. L, 2. A → 2. L).

**Umsetzung:** `effectiveAuslieferungWochentage` wird genutzt; `tageAzuL` pro Intervall aus der Differenz zwischen zugeordnetem A- und L-Tag berechnen (oder als Liste speichern).

**Option A:** Ein Intervall pro A-Tag; L-Datum = zugeordneter L-Wochentag (nächster passender nach A).  
**Option B:** Explizite Paare `(aTag, lTag)` speichern – aufwendiger, aber eindeutig.

**Empfehlung:** Option A; Zuordnung 1:1 über Index `min(i, lTage.size)`.

---

## 4. Logik-Phasen

### Phase 1: Same-Day-Strategie (L = A+0 vs. A+7)

**Betroffene Stellen:**

- `TerminAusKundeUtils.erstelleIntervalleAusKunde` (oder neue Funktion)
- `TerminBerechnungUtils.berechneTermineFuerIntervall` / `berechneWiederholendeTermine`
- `CustomerIntervall` – neues Feld `sameDayLStrategy`

**Logik:**

- Wenn `aTag == lTag` und `sameDayLStrategy == 0`: L-Datum = A-Datum (selber Tag).
- Wenn `aTag == lTag` und `sameDayLStrategy == 7`: L-Datum = A-Datum + 7 Tage.
- Wenn `aTag != lTag`: tageAzuL wie bisher (Differenz der Wochentage, ggf. 7 wenn L vor A in der Woche).

**Rückwärtskompatibilität:** `sameDayLStrategy == null` → Default z. B. `0` (L am selben Tag), damit Verhalten deterministisch bleibt.

---

### Phase 2: Mehrere L-Tage + Zuordnung 1:1

**Szenario:** A-Tage = [Mo, Mi], L-Tage = [Do, Fr].  
Zuordnung: Mo→Do, Mi→Fr.

**Umsetzung:**

- `erstelleIntervalleAusKunde` erzeugt für jeden A-Tag ein Intervall.
- Für A-Tag an Index `i`: L-Tag = `lTage.getOrElse(i) { lTage.lastOrNull() ?: aTag }`.
- tageAzuL = Tage von A-Wochentag bis L-Wochentag (0–7).

**Edge Cases:**

- Mehr A- als L-Tage: Letzter L-Tag wird wiederholt.
- Mehr L- als A-Tage: Überschüssige L-Tage ignoriert (oder dokumentieren).

---

### Phase 3: Vordefinierte Intervalle (7, 14, 21, 28 …)

**Aktuell:** `intervallTage` frei wählbar (1–365).  
**Ergänzung:** UI bietet Chips (7, 14, 21, 28, 35, 42, 56) – dahinter weiterhin `intervallTage`.

Keine Datenmodell-Änderung nötig. Nur UI-Anpassung.

---

### Phase 4: Live-Preview-Text

**Format:** „Nächster Termin: Mo 17.02. A, Do 20.02. L (jede Woche).“ oder  
„Di: A+L. So: A+L. …“ (bei Same-Day sameDay=0).

**Umsetzung:**

- Hilfsfunktion `buildPreviewText(customer, allListen, abDatum)` in Util oder ViewModel.
- Nutzt `TerminBerechnungUtils.berechneAlleTermineFuerKunde` für die nächsten 1–2 Termine.
- Formatiert in natürliche Sprache (Wochentag, Datum, A/L/AL).

---

## 5. UI-Anpassungen (CustomerDetail / TermineTab)


| Element        | Änderung                                                                                         |
| -------------- | ------------------------------------------------------------------------------------------------ |
| A-Wochentage   | Chips mit **Mehrfachauswahl** (Toggle) statt Single-Select                                       |
| L-Wochentage   | Chips mit **Mehrfachauswahl**                                                                    |
| Same-Day-Block | Einblenden wenn `aTage == lTage` (Mengengleich); Radio „L am selben Tag“ / „L eine Woche später“ |
| Intervall      | Chips: Jede Woche, Alle 2 Wo, … (7, 14, 21, 28, 35, 42, 56)                                      |
| Preview        | Textfeld mit Live-Aktualisierung bei Änderung                                                    |
| Art            | Wiederkehrend / Einmalig (ggf. aus v2; evtl. schon vorhanden)                                    |


---

## 6. Implementierungsreihenfolge

1. **Datenmodell** – `sameDayLStrategy` zu CustomerIntervall hinzufügen (optional).
2. **Phase 1** – Same-Day-Logik in `TerminAusKundeUtils` und Terminberechnung.
3. **Phase 2** – Zuordnung 1:1 bei mehreren A/L-Tagen in `erstelleIntervalleAusKunde`.
4. **Phase 3** – UI: Intervall-Chips (keine Logik-Änderung).
5. **Phase 4** – Live-Preview-Text.
6. **UI** – Mehrfachauswahl A/L, Same-Day-Block einbauen.

---

## 7. Rückwärtskompatibilität (Checkliste)

- Neue Felder nur **optional** (null/fehlend erlaubt).
- Alte App: Liest `sameDayLStrategy` nicht; Verhalten unverändert.
- Firebase: Keine Löschung/Umbenennung bestehender Felder.
- Bestehende Kunden mit einem A-Tag: Weiterhin ein Intervall, kein Verhalten bruch.
- TourPlanner, TourDataProcessor, TerminCache: Keine Breaking Changes.

---

## 8. Abhängigkeiten und Referenzen

- `TerminAusKundeUtils.kt` – Intervall-Erstellung
- `TerminBerechnungUtils.kt` – Terminberechnung
- `Customer.kt` / `CustomerIntervall.kt` – Datenmodell
- `CustomerDetailScreen.kt`, `CustomerDetailTermineTab.kt` – UI
- `WochentagBerechnung.kt` – Wochentags-Differenz
- `.cursor/rules/zweites-geraet-kompatibilitaet.mdc` – Kompatibilitätsregeln

