<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bericht App-Zustand – Alle Punkte als Beispiel</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      background: #f5f5f5;
      color: #1a1a1a;
      padding: 16px;
      line-height: 1.5;
    }
    .wrap { max-width: 720px; margin: 0 auto; }
    h1 { font-size: 22px; margin: 0 0 8px; color: #1565c0; }
    h2 { font-size: 18px; margin: 24px 0 12px; padding-bottom: 6px; border-bottom: 2px solid #1976d2; color: #0d47a1; }
    h3 { font-size: 15px; margin: 16px 0 8px; color: #333; }
    p { margin: 0 0 10px; font-size: 14px; }
    ul { margin: 0 0 12px; padding-left: 20px; }
    li { margin-bottom: 4px; }

    .card {
      background: #fff;
      border-radius: 10px;
      padding: 14px 16px;
      margin-bottom: 12px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
      border-left: 4px solid #1976d2;
    }
    .card.warn { border-left-color: #f57c00; }
    .card.ok { border-left-color: #2e7d32; }
    .card .label { font-size: 11px; text-transform: uppercase; color: #666; margin-bottom: 4px; }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin: 12px 0;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #eee; }
    th { background: #e3f2fd; color: #1565c0; font-weight: 600; }
    tr:last-child td { border-bottom: none; }

    .flow {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: #fafafa;
      border-radius: 8px;
      margin: 12px 0;
      font-size: 13px;
    }
    .flow .box {
      padding: 8px 12px;
      border-radius: 6px;
      background: #fff;
      border: 1px solid #ddd;
    }
    .flow .box.source { background: #e8f5e9; border-color: #81c784; }
    .flow .box.missing { background: #ffebee; border-color: #e57373; }
    .flow .box.result { background: #fff3e0; border-color: #ffb74d; }
    .flow .arrow { color: #666; font-size: 18px; }

    .side-by-side { display: flex; gap: 16px; flex-wrap: wrap; }
    .side-by-side > div { flex: 1; min-width: 260px; }

    .option-card {
      background: #fff;
      border: 2px solid #1976d2;
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 12px;
    }
    .option-card h4 { margin: 0 0 8px; font-size: 14px; color: #1565c0; }
    .option-card code { font-size: 12px; background: #f5f5f5; padding: 2px 6px; border-radius: 4px; }

    .model-box {
      font-family: monospace;
      font-size: 12px;
      background: #263238;
      color: #aed581;
      padding: 12px;
      border-radius: 8px;
      margin: 8px 0;
      overflow-x: auto;
    }
    .model-box .same { color: #ffab91; }

    .ui-mock {
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin: 12px 0;
    }
    .ui-mock .bar { background: #1976d2; color: #fff; padding: 10px 12px; font-size: 14px; font-weight: 600; }
    .ui-mock .body { padding: 12px; background: #fff; font-size: 13px; }
    .ui-mock .row { padding: 8px 0; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; }
    .ui-mock .row:last-child { border-bottom: none; }
    .ui-mock .badge { font-size: 11px; padding: 2px 8px; border-radius: 4px; background: #e3f2fd; color: #1565c0; }

    .toc { background: #e3f2fd; padding: 14px 18px; border-radius: 10px; margin-bottom: 24px; }
    .toc ul { list-style: none; padding: 0; margin: 0; }
    .toc li { margin: 6px 0; }
    .toc a { color: #1565c0; text-decoration: none; font-weight: 500; }
    .toc a:hover { text-decoration: underline; }

    .summary { background: #e8f5e9; border-left: 4px solid #2e7d32; padding: 14px; border-radius: 0 8px 8px 0; margin-top: 24px; }
    .summary h3 { margin-top: 0; color: #1b5e20; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Bericht App-Zustand (Feb 2026) – alles gemeint, als Beispiel</h1>
    <p>Diese HTML-Seite zeigt <strong>alle</strong> Punkte aus <code>BERICHT_APP_ZUSTAND_2026_02.md</code> als lesbare Beispiele (kein App-Code).</p>

    <nav class="toc">
      <strong>Inhalt</strong>
      <ul>
        <li><a href="#section1">1. Gesamtzustand der App</a></li>
        <li><a href="#section2">2. Code-Verbesserungen</a></li>
        <li><a href="#section3">3. Mögliche Fehler / Lücken</a></li>
        <li><a href="#section4">4. Termin-Berechnung vereinheitlichen</a></li>
        <li><a href="#section5">5. Design und Termin-Felder</a></li>
        <li><a href="#section6">6. Termin- und Intervall-Arten</a></li>
        <li><a href="#section7">7. Kurzfassung</a></li>
      </ul>
    </nav>

    <!-- ========== 1. Gesamtzustand ========== -->
    <h2 id="section1">1. Gesamtzustand der App</h2>
    <div class="card ok">
      <div class="label">Manifest</div>
      <p>PROJECT_MANIFEST.md: Scope (bis 500 Kunden), Kernfunktionen und Technik dokumentiert.</p>
    </div>
    <div class="card ok">
      <div class="label">Architektur</div>
      <p>Schwere Screens: Coordinator + ViewModel. Termin-Logik in Utils/Processor, nicht in der Activity.</p>
    </div>
    <div class="card ok">
      <div class="label">Termin-Berechnung</div>
      <p><strong>Zentrale Stelle:</strong> TerminBerechnungUtils (Intervall, Wochentag, listenTermine, MONTHLY_WEEKDAY). Cache: TerminCache (365 Tage). Filter: TourDataFilter.</p>
    </div>
    <div class="card ok">
      <div class="label">TODOs</div>
      <p>Keine TODO/FIXME in Kotlin-Dateien gefunden.</p>
    </div>

    <!-- ========== 2. Code-Verbesserungen ========== -->
    <h2 id="section2">2. Code-Verbesserungen (ohne Verhalten zu brechen)</h2>
    <table>
      <thead><tr><th>Thema</th><th>Befund</th><th>Vorschlag</th></tr></thead>
      <tbody>
        <tr>
          <td><strong>Deprecated Felder</strong></td>
          <td>Customer: abholungDatum, auslieferungDatum, wiederholen, intervallTage, letzterTermin, wochentag, listenWochentag (@Exclude/@Deprecated).</td>
          <td>Beibehalten bis Migration; keine Löschung ohne Prüfung aller Referenzen.</td>
        </tr>
        <tr>
          <td><strong>Customer.getFaelligAm()</strong></td>
          <td>Bereits @Deprecated, delegiert an TerminBerechnungUtils.naechstesFaelligAmDatum.</td>
          <td>Aufrufer auf naechstesFaelligAmDatum/effectiveFaelligAmDatum umstellen, dann getFaelligAm() entfernen.</td>
        </tr>
        <tr>
          <td><strong>Doppelte Intervall-Logik</strong></td>
          <td>TourDataFilter: isIntervallFaelligAm / isIntervallFaelligInZukunft. TourPlannerDateUtils: isIntervallFaelligAm (beide für ListeIntervall).</td>
          <td>Eine gemeinsame Implementierung (z. B. TerminBerechnungUtils oder IntervallBerechnungUtils), beide Stellen nutzen sie.</td>
        </tr>
        <tr>
          <td><strong>AgentDebugLog</strong></td>
          <td>In TerminBerechnungUtils und CustomerDetailTermineTab.</td>
          <td>Für Produktion optional (nur Debug-Build) oder entfernen.</td>
        </tr>
      </tbody>
    </table>

    <!-- ========== 3. Mögliche Fehler ========== -->
    <h2 id="section3">3. Mögliche Fehler / Lücken</h2>
    <h3>Was passiert heute?</h3>
    <div class="flow">
      <span class="box source">berechneAlleTermineFuerKunde</span>
      <span class="arrow">→</span>
      <span class="box">liefert nur: Intervalle, Wochentag, listenTermine</span>
      <span class="arrow">→</span>
      <span class="box missing">keine kundenTermine, keine ausnahmeTermine</span>
    </div>
    <div class="flow">
      <span class="box">customerFaelligAm()</span>
      <span class="arrow">,</span>
      <span class="box">getFaelligAmDatumFuerAbholung/Auslieferung</span>
      <span class="arrow">→</span>
      <span class="box result">nutzen nur obige Funktion → können 0 liefern für Kunden nur mit Kunden-/Ausnahme-Terminen</span>
    </div>
    <div class="card ok">
      <div class="label">OK</div>
      <p><strong>hatKundeTerminAmDatum</strong> prüft korrekt: zuerst ausnahmeTermine, dann kundenTermine, dann Cache (berechnet).</p>
    </div>
    <div class="card warn">
      <div class="label">Empfehlung</div>
      <p>Eine <strong>einheitliche Quelle</strong>, die alle Quellen (Intervall, Wochentag, Liste, kundenTermine, ausnahmeTermine) zusammenführt, und überall für „nächstes Fälligkeitsdatum“ / Erledigung nutzen.</p>
    </div>

    <!-- ========== 4. Termin-Berechnung vereinheitlichen ========== -->
    <h2 id="section4">4. Termin-Berechnung vereinheitlichen</h2>
    <p><strong>Lücke:</strong> Kunden-Termine und Ausnahme-Termine sind nicht in berechneAlleTermineFuerKunde; Merge passiert an mehreren Stellen (TerminCache.getTerminePairs365, TourDataFilter.hatKundeTerminAmDatum, …).</p>
    <div class="side-by-side">
      <div class="option-card">
        <h4>Option A</h4>
        <p>Neue Funktion z. B. <code>berechneAlleTermineFuerKundeVollstaendig(customer, liste, …)</code>: berechnete Termine + kundenTermine + ausnahmeTermine → eine gemeinsame Liste (z. B. TerminInfo).</p>
        <p>Alle Fälligkeit- und „Termin am Datum“-Logiken nutzen nur noch diese Funktion.</p>
      </div>
      <div class="option-card">
        <h4>Option B</h4>
        <p><code>berechneAlleTermineFuerKunde</code> um optionalen Merge erweitern: <code>includeKundenUndAusnahmeTermine: Boolean = false</code>.</p>
        <p>Überall wo „vollständige“ Termine nötig sind, diesen Modus nutzen.</p>
      </div>
    </div>

    <!-- ========== 5. Design und Termin-Felder ========== -->
    <h2 id="section5">5. Design und Termin-Felder vereinfachen</h2>
    <h3>Aktuell – viele Felder beim Kunden</h3>
    <div class="model-box">
      intervalle, defaultAbholungWochentag/-Wochentage, listenTermine (über Liste),<br>
      kundenTermine, ausnahmeTermine, verschobeneTermine, geloeschteTermine, faelligAmDatum
    </div>
    <h3>Vorschlag – einheitliches Modell für Anzeige</h3>
    <div class="model-box">
      TerminInfo: datum, typ (A/L), <span class="same">quelle</span> (intervall | wochentag | liste | kundenTermin | ausnahme)<br>
      → Eine Liste „alle Termine“ für einen Kunden.
    </div>
    <h3>UI aktuell vs. Vorschlag</h3>
    <div class="side-by-side">
      <div class="ui-mock">
        <div class="bar">Aktuell: Tab Termine &amp; Tour</div>
        <div class="body">
          <div class="row">Nächster Termin</div>
          <div class="row">Kunden-Termine <span class="badge">eigener + Button</span></div>
          <div class="row">Ausnahme-Termine <span class="badge">eigener + Button</span></div>
          <div class="row">Termin-Regeln/Intervalle <span class="badge">„Termin anlegen“</span></div>
          <div class="row">Tour</div>
        </div>
      </div>
      <div class="ui-mock">
        <div class="bar">Vorschlag: Alle Termine</div>
        <div class="body">
          <div class="row">Eine Liste (Datum, A/L, Quelle)</div>
          <div class="row">Gemeinsame Komponente für alle Termin-Typen</div>
          <div class="row"><strong>Ein</strong> „Termin hinzufügen“ → Art wählen (Regelmäßig / Einmalig / Ausnahme)</div>
        </div>
      </div>
    </div>

    <!-- ========== 6. Termin-Arten ========== -->
    <h2 id="section6">6. Termin- und Intervall-Arten</h2>
    <table>
      <thead><tr><th>Art</th><th>Wo</th><th>Daten</th></tr></thead>
      <tbody>
        <tr><td><strong>Regelmäßig (Intervall)</strong></td><td>Customer.intervalle (CustomerIntervall)</td><td>abholungDatum, auslieferungDatum, wiederholen, intervallTage, regelTyp (WEEKLY, …)</td></tr>
        <tr><td><strong>Monatlich (n-ter Wochentag)</strong></td><td>CustomerIntervall, regelTyp MONTHLY_WEEKDAY</td><td>monthWeekOfMonth, monthWeekday, tageAzuL</td></tr>
        <tr><td><strong>Wochentag (ohne Intervall)</strong></td><td>Customer ohne intervalle, effectiveAbholungWochentage</td><td>Termine an diesen Wochentagen, L = A + tageAzuL</td></tr>
        <tr><td><strong>Unregelmäßig / Ad-hoc</strong></td><td>kundenTyp UNREGELMAESSIG / AUF_ABRUF</td><td>Termine über kundenTermine oder ausnahmeTermine</td></tr>
        <tr><td><strong>Kunden-Termine</strong></td><td>Customer.kundenTermine (KundenTermin)</td><td>datum, typ "A"/"L" – vom Kunden vorgegeben</td></tr>
        <tr><td><strong>Ausnahme-Termine</strong></td><td>Customer.ausnahmeTermine (AusnahmeTermin)</td><td>datum, typ "A"/"L" – einmalige Sonderfälle</td></tr>
        <tr><td><strong>Listen-Termine</strong></td><td>KundenListe.listenTermine (KundenTermin)</td><td>A/L für die ganze Liste, für alle Kunden der Liste</td></tr>
        <tr><td><strong>Tour-Listen (Wochentag)</strong></td><td>KundenListe, wochentag in 0..6</td><td>wochentagA, tageAzuL; nächster A an diesem Tag</td></tr>
      </tbody>
    </table>
    <h3>Strukturelle Duplikation</h3>
    <div class="model-box">
      <span class="same">AusnahmeTermin</span> und <span class="same">KundenTermin</span> sind identisch: datum, typ "A"/"L".<br>
      Nur Semantik unterschiedlich (Ausnahme vs. kundenvorgegeben).<br>
      → Vereinheitlichung: z. B. Einzeltermin(datum, typ, quelle: AUSNAHME | KUNDE) oder eine Liste einzelTermine mit Feld „quelle“.
    </div>
    <h3>Vereinfachungsideen</h3>
    <ol>
      <li><strong>Termin-Quelle-Abstraktion:</strong> Alle Termine als „Quelle“ modellieren; eine Stelle liefert „alle Termine für Kunde X am Tag T“.</li>
      <li><strong>Listen-Intervall annähern:</strong> ListeIntervall optional an CustomerIntervall (gemeinsame Felder) annähern für gemeinsame Berechnungslogik.</li>
      <li><strong>Einstiege:</strong> Ein Dialog „Termin hinzufügen“ → „Regelmäßig / Einmalig (Kunden-Termin) / Ausnahme“ → gleiche Felder (Datum, A/L). Für Listen: „Listen-Termin hinzufügen“ mit Datum + A+L.</li>
    </ol>

    <!-- ========== 7. Kurzfassung ========== -->
    <h2 id="section7">7. Kurzfassung</h2>
    <div class="summary">
      <h3>Kurzfassung</h3>
      <ul>
        <li><strong>App-Stand:</strong> Stabil, Architektur und Manifest stimmig, keine TODOs in Kotlin.</li>
        <li><strong>Verbesserungen:</strong> Deprecated sauber abräumen, doppelte Intervall-Logik zusammenführen, Debug-Log optional.</li>
        <li><strong>Wichtiger Punkt:</strong> Fälligkeit und Erledigung berücksichtigen aktuell nicht kundenTermine/ausnahmeTermine überall; Vereinheitlichung über eine „vollständige“ Termin-Quelle empfohlen.</li>
        <li><strong>Vereinfachung:</strong> Termin-Berechnung an einer Stelle inkl. Kunden-/Ausnahme-Termine; gemeinsame UI für Termin-Listen; optional einheitliches Modell für Einzeltermine und ein gemeinsamer „Termin hinzufügen“-Flow.</li>
      </ul>
    </div>

    <p style="margin-top:32px;font-size:12px;color:#888;">Letzte Aktualisierung: Feb 2026 – Bezug: BERICHT_APP_ZUSTAND_2026_02.md</p>
  </div>
</body>
</html>
